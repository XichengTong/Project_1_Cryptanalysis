## Assignment

**Grading and Submission Policies:** Project 1 will contribute to the class grade as specified in the syllabus. All students must submit for Project 1 using the appropriate link in the Quizzes website area, and using the submission naming convention specified below. If you want just one group member to submit your long submission, the other team members have to submit some text or file with a pointer to the submitting student in their team.

The project should be realized by a team of, ideally, 2 or 3 students (well motivated exceptions for 1-student or 4-student teams will be likely accepted). Each team has to detail which tasks were done by which student. The implementation can be in any programming language, but it is strongly recommended to use Python to help us with automated testing of your submission. The project comes with a minimal assignment and requires a submission of both software and a report being graded mainly by the TAs according to scoring criteria defined below; any additional work you perform might be considered extra credit work if later also submitted under the appropriate space in the Quizzes website area.  

**<ins>Project 1 (Cryptanalysis of a class of ciphers):</ins>**

This cryptanalysis project consists of a software implementation of an algorithm that tries to decrypt an L-symbol challenge ciphertext computed using a specific cipher. Informally speaking, your program's goal is to find the plaintext used to compute this ciphertext within a reasonable amount of time. Specifically, your program **must**:

   1. print on screen "Enter the ciphertext:",
   
   2. obtain the ciphertext from stdin,
   
   3. apply some cryptanalysis strategy (of your choice) and 
   
   4. output on screen "My plaintext guess is:" followed by the plaintext found by your strategy. 

**Please carefully follow these instructions**, as we will automatically test your submissions.

In other words, **no variations to the above instructions**. Thanks for your understanding.

In its cryptanalysis strategy, your program <ins>is allowed</ins> access to:
   1. The ciphertext (to be taken as input from stdin).
   
   2. A plaintext dictionary (to be posted on top of this web page), containing a number u of plaintexts, each one obtained as a sequence of space-separated words from the English dictionary
   
   3. Partial knowledge of the encryption algorithm used (to be described below).

In its cryptanalysis strategy, your program <ins>is not allowed </ins>access to:
   1. The key used by the cipher.
   
   2. Part of the encryption scheme (to be detailed below).

The plaintext is a space-separated sequence of words from the English dictionary; thus, each symbol is either a space or one of the 26 lower-case letters from the English alphabet and cannot be a special character, punctuation symbol or upper-case letter; the sentence may not be meaningful, for sake of simplicity.

The key is a sequence of t numbers between 0 and 26.  

The ciphertext looks like a sequence of symbols from {<space>,a,..,z}.

A text file plaintext_dictionary containing a number u of L-symbol candidate plaintexts will be provided to you (as an attachment at the top of this page), and you should feel free to use its content as part of your code.

Your program will be run using different parameters (e.g., L=600, u=5, and, if needed, t between 1 and 20), and on a number of challenge ciphertexts, each computed using a potentially different variant of the encryption scheme.

Your program should return as output a guess for which L-symbol plaintext was encrypted.

Each ciphertext will be computed from a plaintext generated by randomly and independently choosing one of the L-symbol plaintexts in the plaintext dictionary.

All the encryption schemes used have the following common features:

- The message space is the set `{<space>,a,..,z}^L`. In other words, the message m can be written as m[1],...,m[L], where each m[i] is in `{<space>,a,..,z}`.
- The ciphertext space is the set `{<space>,a,..,z}^{L+r}`, for some r>=0. In other words, the ciphertext c can be written as c[1],...,c[L+r], where each c[i] is in `{<space>,a,..,z}`.
- The key space is the set {0,..,26}^t. In other words the key k can be written as k[1],...,k[t], where each k[j] is in {0,..,26}, for j=1,..,t.
- The encryption algorithm computes the next ciphertext symbol c[i] from the next message symbol m[i'] in two possible ways:
   - as a random value in `{<space>,a,..,z}`, the idea being that of including a random value in the ciphertext to confuse the eavesdropper
   - as a ciphertext character, according to one of the following schemes (your choice which) studied in Lecture 1: 
     - the mono-alphabetic substitution cipher (where t=27)
     - the poly-alphabetic substitution cipher (where t<<27); for instance, in this latter case, this ciphertext character would be the (lexicographic) shift of m[i'] by k[j(i')] positions, where j(i') is equal to i' modulo t. In other words, each ciphertext symbol 
     c[i] is the shift of the plaintext symbol m[i'] by a number of position equal to one of the key symbols, which symbol being chosen exactly as in the polyalphabetic substitution cipher (i.e., the next key symbol, cycling from the last to the first). Note that i (the ciphertext position pointer) and i' (the message position pointer) will be more and more different as more random ciphertext symbols are inserted in the ciphertext. 
   - which of these two ways happens is left <ins>unspecified</ins> and and may depend on i',t,L. In other words, whether the ciphertext symbol is a map from a plaintext symbol or just a random value is being chosen according to an undisclosed, and not key-based, "coin generation" algorithm that is a function of i', t and L, and returns a coin value in [0,1] which is compared with a pre-set parameter prob_of_random_ciphertext
- A pseudocode description of the encryption algorithm (in the case of the polyalphabetic substitution cipher) could go as follows:
  - Input: key k=k[1],...,k[t] and message m=m[1],...,m[L]
  - Instructions:
    - ciphertext_pointer = 1 
    - message_pointer = 1
    - num_rand_characters = 0
    - prob_of_random_ciphertext = 0.05
    - Repeat
      - let coin_value =
        coin_generation_algorithm(ciphertext_pointer,t,L)  //
        coin_value is a real number in [0,1]
      - if prob_of_random_ciphertext <= coin_value <= 1 then
        - set j = (message_pointer mod t) + 1
        - set c[ciphertext_pointer] = character obtained after forward shifting m[message_pointer] by k[j] positions on the cycle `{<space>,a,..,z}`
        - message_pointer = message_pointer + 1
      - if 0 <= coin_value < prob_of_random_ciphertext then
        - randomly choose a character c from `{<space>,a,..,z}`
        - set c[ciphertext_pointer] = c
        - num_rand_characters = num_rand_characters + 1
      - ciphertext_pointer = ciphertext_pointer +1   
    - Until ciphertext_pointer > L + num_rand_characters
    - Return c[1]...c[L + num_rand_characters]

Note that, for instance, the poly-alphabetic substitution cipher, as described in Lecture 1, is a particular example of this cipher where prob_random_ciphertext = 0 (in other words, no random characters are inserted in the ciphertext).  

Your program will be scored based on some test where your program will be run a few times (e.g., 10), each time on a new ciphertext, computed using the above encryption scheme (relatively to your chosen classical cipher; i.e. shift, monoalphabetic substitution or polyalphabetic substitution) and a plaintext randomly chosen from the plaintext_dictionary, and a potentially different choice of the prob_of_random_ciphertext and the coin generation algorithm. In this test we will likely choose L=600, and a plaintext dictionary with u=5 plaintexts. Alternatively, we may also test what is the largest prob_of_random_ciphertext that your program succeeds on. 

To test your strategy, you may use a random coin generation algorithm (i.e., returning a random value in [0,1]) and increasing values for prob_of_random_ciphertext (e.g., 0.05, 0.10, 0.15, etc).

Your executable file should be named `"<last name1>-<last name2>-<last name3>-decrypt" `(assuming a 3-person team here). Upon execution, it should obtain the ciphertext from stdin, and finally return the output plaintext on stdout within x minutes (or else it will be declared to default to an incorrect guess); most likely, we will choose x = 1 on test 1 and x = 3 on test 2.

If you think of more than one cryptanalysis approach, you have to combine them into a single approach, as only a single approach per team can be tested.  

Your accompanying **report** should at least include the following sections:

 1. title of your project (based on your approach); something like "Cryptanalysis of a class of ciphers based on (...)"; the symbol (...) should be replaced with an expression summarizing the main idea(s) in your approach

 2. an introduction containing the team member names; the list of project tasks performed by each student in the team; the number of cryptanalysis approaches you are submitting; which classical cipher you chose among the 3 mentioned cipher (shift, monoalphabetic substitution and polyalphabetic substitution) and all modifications (if any) you made with respect to the above specifications

 3. a detailed informal explanation (using much more English than pseudo-code) of the cryptanalysis approach or approaches used in your program

 4. a detailed rigorous description (using much more pseudo-code than English) of the cryptanalysis approach or approaches used in your program

Allowed extensions (to be considered as **extra credit**) include any one among the following:
 1. if you think your cryptanalysis strategy works well (meaning, it quickly finds the plaintext from the ciphertext) for the given dictionary file, try increasing the number of candidate plaintexts in this file and see if your strategy still works well, possibly relaxing the restriction on x minutes of running time; report the number (of candidate plaintexts in this file) when you note a large increase in your strategy's running time for each prob_of_random_ciphertext value in {0, 0.05, 0.1, 0.15, 0.2, 0.25,...,0.75}; ideally, reporting pictures showing the runtime as a function of the number of candidate plaintexts in this file;
 2. similar to (1), but fixing the number of plaintexts and increasing the prob_of_random_ciphertext value; specifically: if you think your cryptanalysis strategy works well (meaning, it quickly finds the plaintext from the ciphertext) for the given dictionary file and a small prob_of_random_ciphertext value, try increasing this value and see if your strategy still works well, possibly relaxing the restriction on x minutes of running time; report the prob_of_random_ciphertext value when you note a large increase in your strategy's running time; ideally, reporting pictures showing the runtime as a function of the prob_of_random_ciphertext value.

Your submission can be a zip file (not a link to a github repository), submitted on this website, in the appropriate space under Quizzes. 

Either of the two must contain at least the following files:
   - project report (in pdf form)
   - source
   - executable (if different than source). 

All of these files (including any requirements.txt file) need to be in the top directory (as opposed in some subdirectory).

You must name your zip file as (assuming a team of 3 students here): `<last-name1><last-name2><last-name3>-cs6903f24project1` and your contained files as
- `<last-name1><last-name2><last-name3>-report`
- `<last-name1><last-name2><last-name3>-decrypt-source`
- `<last-name1><last-name2><last-name3>-decrypt-executable` (if applicable)


Your submission will be judged based on the following **grading criteria**:

  1. software correctness and usability (i.e., if you followed all of the above instructions, if software runs correctly, and is easy to use)
  
  2. quality of report (i.e., how well written is your report)
  
  3. how interesting is your cryptanalysis approach (i.e., in terms of novelty of the ideas used in your algorithm) or/and how successful is your cryptanalysis success (i.e., how many challenge ciphertexts your program successfully decrypted). If there are two or more submissions successfully decrypting the same number of challenge ciphertexts, we may rank them based on their (faster to slower) running time taken to produce their outputs.

A cryptanalysis strategy which is either somewhat interesting or somewhat successful will be rewarded with a score at least at the B or B+ level. A cryptanalysis strategy which is either very interesting or very successful will be rewarded with a score at least at the A- level. A cryptanalysis strategy which is either very interesting and somewhat successful, or somewhat interesting and very successful will be rewarded with a score in the A level.

The top team(s) will be announced and rewarded with extra credit if they later record a short video with a presentation of their strategy.

**Due date** is on the syllabus. No late submissions can be accepted without score penalty and early submissions are encouraged. You are strongly recommended to submit any questions to the TAs (see Syllabus content area for their contact info) and the instructor.
